\section{Метод решения}
Алгоритм карманная сортировки:
\begin{enumerate}
\item Разбить все данные на $n\_split$ карманов. Здесь $n\_split = {{n - 1} \over {split\_size}} + 1$, $split\_size$ --- размер кармана.
\item Если рядом оказываются два кармана, суммарный размер которых не первышает размер кармана $split\_size$, то они объединяются.
\item Для карманов, размеров которых первышает $split\_size$ рекурсивно вызывается карманная сортировка для дальнейшего разбиения, для остальных карманов вызывается чет-нечет сортировка внутри каждого кармана.
\end{enumerate}

Первый шаг алгоритма требует вычисления максимума и минимума, построения гистораммы и вычисления массива префиксных сумм.

Максимум и минимум могут быть вычислены параллельно с помощью редукции, основная идея которой заключается в другом порядке операций --- вместо того, что последовательно сравнивать максимум и элемент, мы будет сравнивать все пары чисел, затем все пары результатов сравнения и так далее, алгоритм похож на построение дерева отрезков за $O(n)$.

Для параллельного построения гистограммы требуется выполнять атомарное сложение, чтобы избежать гонки потоков --- \texttt{atomicAdd}.

Префиксные суммы вычисляютя параллельно с помощью алгоритма \texttt{blelloch scan}. Он подробно описан в \cite{scan}. Идея в том, чтобы вычислить префиксные суммы для одного блока, который помещается в разделяюмую память, затем добавить к каждому элементу следующего блока суммы всех предыдущих блоков. Чтобы сделать это эффективно, необходимо вызвать рекурсивно \texttt{scan} для массива сумм блоков.

Второй шаг алгоритма выполняется на центральном процессоре обычным проходом в цикле.

Для чет-нечет сортировки для кармана необходимо сначала загрузить его в разделяемую память, затем каждый поток сравнивает пары элементов (начиная с чётного или нечётного индекса в зависимости от фазы алгоритма) и меняет их в случае неупорядоченности по неубыванию.
\pagebreak

\section{Описание программы}
Вычисление максимума и минимума с помощью редукции реализовано в функциях \texttt{max\_val}, \texttt{min\_val} и ядрах \texttt{max\_val\_reduction}, \texttt{min\_val\_reduction} соответственно. Пока размер массива первышает размер одного блока, вызывается ядро свёртки, результат выполнения каждого блока записывается по индексу самого блока в новый массив.

Построение гистограммы реализовано в функции \texttt{build\_hist}, она вычисляет максимальный элемент массива и вызывает ядро \texttt{cnt\_kernel\_gl} --- построение гистограммы в глобальной памяти. При желании можно реализовать параллельное построение гистограммы для массивов из небольних элементов на разделяемой памяти.

Вычисление массива префиксных сумм реализовано в шаблонной функции \texttt{scan}, которая вызывает ядро \texttt{scan\_kernel}, оно же проходит по всем блокам и в каждом вызывает ядро \texttt{scan\_block}. Если размер массива превышает максимальный размер блока, то \texttt{scan} вызывается рекурсивно для массива сумм каждого блока, после чего вызывается ядро \texttt{update\_kernel}, прибавляющее эти значения к элементам блоков.

Чет-нечет сортировка реализована в ядре \texttt{odd\_even\_kernel}. Каждый поток хранит флаг \texttt{flag}, отвечающий за фазу алгоритма --- чётную или нечётную. Так как каждый раз проверять отсортированность массива долго, алгоритм проходит по всем $n$ фазам.

Для карманной сортировки реализованы ядра \texttt{key\_kernel} и \texttt{distribution\_kernel}. Первое нужно для вычисления номера кармана каждого элемента, а второе для распределения элементов по карманам. Функция \texttt{process\_pockets} реализует второй шаг алгоритма, описанного ранее. Сами карманы хранятся в структуре \texttt{pocket} из двух полей $pos$ и $len$ --- индекса начала и размера кармана.
