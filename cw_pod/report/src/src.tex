\section{Метод решения}

\subsection{Освещение}
Для построения фотореалистичного изображения буду использовать простую модель освещения:
$$ I = I_a + I_d + I_s $$
где $I_a$ --- фоновая составляющая, $I_d$ --- рассеянная составляющая, $I_a$ --- зеркальная составляющая.

\subsubsection{Фоновая составляющая}
Даже при отсутсвии света в комнате мы может различать объекты, потому что лучи отражаются от всех поверхностей в комнате. Расчёт всех отражений слишком сложный, поэтому для простоты каждый объект получает часть фонового освещения:
$$ I_a = k_a \cdot i_a $$
где $k_a$ --- свойство материала воспринимать фоновое освещени, $i_a$ --- мощность фонового освещения.

\subsubsection{Рассеянная составляющая}
Рассеянное отражение света происходит, когда свет как бы проникает под поверхность объекта, поглощается, а затем вновь испускается.
При этом положение наблюдателя не имеет значения, так как диффузно отраженный свет рассеивается равномерно по всем направлениям.

Интенсивность света обратно пропорциональна квадрату расстояния от источника, следовательно, объект, лежащий дальше от него, должен быть темнее. Для простоты буду применять модель $d + K$, так как в модели обратных квадратов для $|d| \leqslant 1$ будет осветление объекта, что нужно отдельно обрабатывать. Константа $K$ в этом выражении подбиратеся из соображений эстетики.

Выражение для рассеянного освещения имеет следующий вид:
$$ I_d = {{k_d \cdot i_l} \over {d + K}} \cdot \cos(\vec{L}, \vec{N}) $$
где $k_d$ --- свойство материала воспринимать рассеянное освещение, $i_l$ --- интенсивность точеченого источника, $\vec{L}$ --- направление из точки на источник света, $\vec{N}$ --- вектор нормали в точке, $K$ --- произвольная постоянная, $d$ --- расстояние от источника света до точки.

\subsubsection{Зеркальная составляющая}
Интенсивность зеркально отраженного света зависит от угла падения, длины волны падающего света и свойств вещества отражающей поверхности. Зеркальное отражение света является направленным. Так как физические свойства зеркального отражения очень сложны, используется коээфициент глянцевости материала:
$$ I_s = {{k_s \cdot i_l} \over {d + K}} \cdot {\cos ^ p}(\vec{R}, \vec{S}) $$
где $k_s$ --- свойство материала воспринимать зекральное освещение, $\vec{R}$ --- вектор отражённого от поверхности луча, $\vec{S}$ --- вектор наблюдения, $p$ --- глянцевость материала.

\subsection{Трассировка лучей}
При обратной трассировке лучи испускаются из камеры. Каждый пиксель на экране --- это отдельный луч, который попадает на объекты сцены, отражается и преломляется. С помощью модели освещения вычисляется интенсивность цвета в точке, результат записывается в пиксель, соответствующий лучу.

\subsubsection{Рекурсивная трассировка лучей}
Так как каждый луч может породить два луча (отражённый и преломлённый), вычисление интенсивности происходит рекурсивно. Честная рекурсивная реализация достаточно медленная, поэтому на каждом шаге рекурсии нужно хранить два массива лучей --- для текущего шага и для следующего. Для каждого луча вычисляется интенсивность, если луч отражается или преломлеятся, то эти лучи записываются в новый массив.

\subsection{Загрузка сцены}
Все полигоны на сцене хранятся в едином массиве. Многогранники загружаются из \texttt{obj} файлов, для них генерируются рёбра и источника света на рёбрах.

\subsubsection{Наложение текстур}
Для произвольного наложения текстуры на пол для каждого полигона пола я ввожу базис из двух векторов, достраивая треугольник до параллелограмма так, что любую точку в нём можно разложить по формуле
$$ \vec{p} = \alpha \cdot \vec{v_1} + \beta \cdot \vec{v_2} $$
где $\vec{p}$ --- точка параллелограмма, $\vec{v_1}$ и $\vec{v_2}$ --- базисные векторы, $0 \le \alpha, \beta \le 1$ --- коэффициенты разложения.

Зная коэффициент $\alpha$ и $\beta$, достаточно умножить их на высоту и ширину текстуры, чтобы получить цвет соответствующего пикселя текстуры.

\subsection{Сглаживание}
Для получения более красивой картинки используется алгоритм \texttt{SSAA}. Для каждого пикселя испускается несколько лучей, полученные интенсивности усредняются.
\pagebreak

\section{Описание программы}
\texttt{phong\_shading} вычисляет интенсивность освещения в точке. Функция возвращает трёхмерный вектор цветов, принимает указатели, поэтому работает как на центральном, так и на графическом процессоре.

Трассировка лучей реализована в функциях \texttt{trace} и \texttt{trace\_gpu}, реализующих алгоритм, описанный выше. Каждый луч пересекается с каждым полигоном на сцене. Для параллельной записи новых лучей используется функция \texttt{atomicAdd}.

Текстурные объекты класса \texttt{texture\_t} хранят два указателя --- в оперативной памяти и в графической памяти. Поэтому доступ к пикселям текстур одинаковый как на центральном, так и графическом процессоре.

Сглаживание реализовано в функциях \texttt{ssaa\_cpu} и \texttt{ssaa\_gpu}.

\subsection{Разделение по файлам}
Программа состоит из следующих файлов:
\begin{itemize}
    \item \texttt{io.cuh} --- функция для чтения и записи изображения в бинарном формате;
    \item \texttt{polygon.cuh} --- описание класса луча, треугольника и полигона;
    \item \texttt{ray\_cpu.cuh} --- функции для трассировки лучей на центральном процессоре;
    \item \texttt{ray\_gpu.cuh} --- ядра для трассировки лучей на графическом процессоре;
    \item \texttt{scene.cuh} --- функция для чтения и обработки \texttt{obj} файлов, загрузка сцены;
    \item \texttt{ssaa.cuh} --- функция и ядро, реализующие алгоритм
    \texttt{SSAA};
    \item \texttt{textures.cuh} --- описание класса текстуры;
    \item \texttt{utils.cuh} --- функция для печати информации о графическом процессоре, класс таймера и макрос для проверки успешного выполнения системных вызовов;
    \item \texttt{variables\_cpu.cuh} --- переменные, необходимые для ввода данных и исполнения программы;
    \item \texttt{variables\_gpu.cuh} --- указатели в графической памяти, необходимые для исполнения программы на графическом процессоре;
    \item \texttt{vector3d.cuh} --- описание шаблонного класса вектора с перегруженными операторами;
    \item \texttt{main.cu} --- главный исполняемый файл.
\end{itemize}


\pagebreak
